---
title: "JSC370 - Midterm Project"
subtitle: "[Link to Github Repository](https://github.com/tirangol/JSC370-Project)"
author: 'Richard Yin'
date: '14 March 2025'
output: 
  html_document: 
    theme: paper
---

<!--
NOTE TO WHOEVER IS RUNNING THIS CODE

The preprocessing code is relatively slow. I ended up saving the output dataframe, setting the preprocessing code blocks to eval=FALSE, and loading the processed dataframe each time for the sake of speed.

The saved dataframe is a file called dataset.Rda. If you want to run the preprocessing code from scratch, you should remove the eval=FALSE lines in each block of code.
-->

```{r include=FALSE}
library(httr)
library(ggplot2)
library(dplyr)
library(rvest)
library(stringr)
library(jsonlite)
library(hash)
library(patchwork)
```

```{r Get Pokemon/types/moves, eval=FALSE, include=FALSE}
response <- GET(url='https://www.smogon.com/dex/sm/pokemon/')
data <- read_html(response)
script <- html_text(html_nodes(data, "script")[4])
json <- fromJSON(substring(script, 15, 10000000))

rows <- NULL
i <- 0
for (x in json$injectRpcs) {
  if (i == 1) {
    rows <- x[[2]]
  }
  i <- i + 1
}
POKEDEX <- rows$pokemon
TYPES <- rows$types
MOVES <- rows$moves

TYPES <- TYPES |>
  select(name, atk_effectives)

MOVES <- MOVES |>
  filter(isNonstandard != 'CAP') |>
  select(name, category, power, accuracy, priority, description, type, target)
```


```{r Type effectivenes, eval=FALSE, include=FALSE}
n <- nrow(TYPES)
TYPE_MATRIX <- matrix(NA, nrow=n, ncol=n)
for (i in 1:n) {
  TYPE_MATRIX[,i] <- as.numeric(TYPES[i,]$atk_effectives[[1]][,2])
}
TYPE_DICT <- hash()
for (i in 1:n) {
  name <- TYPES[i,1]
  TYPE_DICT[[name]] <- factor(TYPE_MATRIX[i,], levels=unique(TYPE_MATRIX[i,]))
}
for (i in 1:n) {
  for (j in 1:i) {
    if (i == j) next()
    t1_name <- TYPES[i,1]
    t2_name <- TYPES[j,1]
    t <- TYPE_MATRIX[i,] * TYPE_MATRIX[j,]
    name1 <- paste(t1_name, t2_name, sep=',')
    name2 <- paste(t2_name, t1_name, sep=',')
    t <- factor(t, levels=unique(t))
    TYPE_DICT[[name1]] <- t
    TYPE_DICT[[name2]] <- t
  }
}
```

```{r Pokemon list, eval=FALSE, include=FALSE}
POKEDEX <- POKEDEX |>
  filter(isNonstandard != 'CAP') |>
  select(name, hp, atk, def, spa, spd, spe, types, formats) |>
  mutate(total = hp + atk + def + spa + spd + spe,
         bulk = (hp + def) / 2,
         spbulk = (hp + spd) / 2,
         typecount = factor(sapply(types, length)),
         formats = as.character(formats),
         formats = case_when(formats == 'AG' ~ 'Ubers',
                             formats == 'Uber' ~ 'Ubers',
                             formats == 'NFE' ~ 'LC',
                             formats == 'ZUBL' ~ 'PU',
                             formats == 'PUBL' ~ 'NU',
                             formats == 'NUBL' ~ 'RU',
                             formats == 'RUBL' ~ 'UU',
                             formats == 'UUBL' ~ 'OU',
                             .default = formats),
         stat_dev = sd(c(hp, atk, def, spa, spd, spe)),  #TODO fix
         best_stat = case_when((spbulk == pmax(bulk, spbulk, atk, spa, spe) | bulk == pmax(bulk, spbulk, atk, spa, spe)) & abs(bulk - spbulk) <= 10 ~ 'bulk',
                               bulk == pmax(bulk, spbulk, atk, spa, spe) ~ 'phbulk',
                               spbulk == pmax(bulk, spbulk, atk, spa, spe) ~ 'spbulk',
                               (atk == pmax(bulk, spbulk, atk, spa, spe) | spa == pmax(bulk, spbulk, atk, spa, spe)) & abs(atk - spa) <= 10 ~ 'atk',
                               atk == pmax(bulk, spbulk, atk, spa, spe) ~ 'phatk',
                               spa == pmax(bulk, spbulk, atk, spa, spe) ~ 'spatk',
                               spe == pmax(bulk, spbulk, atk, spa, spe) ~ 'spe'),
         types = as.character(lapply(types, function(x) paste(x, collapse=','))),
         type_defences = lapply(types, function(x) TYPE_DICT[[x]]),
         weaknesses = as.numeric(lapply(type_defences, function(x) sum(as.numeric(as.vector(x)) > 1))),
         resistances = as.numeric(lapply(type_defences, function(x) sum(as.numeric(as.vector(x)) < 1))),
         is_bug = grepl('Bug', types),
         is_dark = grepl('Dark', types),
         is_dragon = grepl('Dragon', types),
         is_electric = grepl('Electric', types),
         is_fairy = grepl('Fairy', types),
         is_fighting = grepl('Fighting', types),
         is_fire = grepl('Fire', types),
         is_flying = grepl('Flying', types),
         is_ghost = grepl('Ghost', types),
         is_grass = grepl('Grass', types),
         is_ground = grepl('Ground', types),
         is_ice = grepl('Ice', types),
         is_normal = grepl('Normal', types),
         is_poison = grepl('Poison', types),
         is_psychic = grepl('Psychic', types),
         is_rock = grepl('Rock', types),
         is_steel = grepl('Steel', types),
         is_water = grepl('Water', types),
         def_bug = sapply(type_defences, function(x) x[1]),
         def_dark = sapply(type_defences, function(x) x[2]),
         def_dragon = sapply(type_defences, function(x) x[3]),
         def_electric = sapply(type_defences, function(x) x[4]),
         def_fairy = sapply(type_defences, function(x) x[5]),
         def_fighting = sapply(type_defences, function(x) x[6]),
         def_fire = sapply(type_defences, function(x) x[7]),
         def_flying = sapply(type_defences, function(x) x[8]),
         def_ghost = sapply(type_defences, function(x) x[9]),
         def_grass = sapply(type_defences, function(x) x[10]),
         def_ground = sapply(type_defences, function(x) x[11]),
         def_ice = sapply(type_defences, function(x) x[12]),
         def_normal = sapply(type_defences, function(x) x[13]),
         def_poison = sapply(type_defences, function(x) x[14]),
         def_psychic = sapply(type_defences, function(x) x[15]),
         def_rock = sapply(type_defences, function(x) x[16]),
         def_steel = sapply(type_defences, function(x) x[17]),
         def_water = sapply(type_defences, function(x) x[18]))
```


```{r Move categorization, eval=FALSE, include=FALSE}
MOVES <- MOVES |>
  mutate(stat_change = category == 'Non-Damaging' & (grepl('[Rr]aises|[Ll]owers', description)),
         multisetup = category == 'Non-Damaging' & grepl('[Ff]or . turns', description),
         heal = grepl('[hH]eal[ s]|recover', description),
         burn = category == 'Non-Damaging' & grepl('[bB]urns', description),
         poison = category == 'Non-Damaging' & grepl('[pP]oisons', description),
         paralyze = category == 'Non-Damaging' & grepl('[pP]aralyzes', description),
         sleep = category == 'Non-Damaging' & grepl('to fall asleep|to sleep', description),
         confuse = category == 'Non-Damaging' & grepl('[cC]onfuse', description),
         status = burn | poison | paralyze | sleep | confuse,
         hazards = grepl('[sS]witch-in|[hH]azard', description),
         switch = grepl('User switch|[sS]witch.* out|[tT]rap|switch to a random ally', description),
         recoil = grepl('recoil', description),
         ohko = grepl('faint|OHKO', description),
         flinch = grepl('[fL]inch', description),
         selfweaken = grepl('[lL]owers the user', description),
         multihit = grepl('[hH]its .+ times', description),
         critical = grepl('[cC]ritical', description),
         protect = category == 'Non-Damaging' & grepl('[pP]rotect|from affecting the user', description),
         multiturn = category != 'Non-Damaging' & grepl('[lL]asts|[Cc]harge|after being used|[cC]annot move|[cC]annot be selected', description),
         move = grepl('last move', description))
```


```{r, eval=FALSE, include=FALSE}
POKEDEX_DICT <- hash()
for (i in 1:nrow(POKEDEX)) {
  name <- POKEDEX[i,1]
  POKEDEX_DICT[[name]] <- POKEDEX[i,2:ncol(POKEDEX)]
}
MOVES_DICT <- hash()
for (i in 1:nrow(MOVES)) {
  MOVES_DICT[[MOVES[i,1]]] <- MOVES[i,]
}

# Add extra moveset for hidden power
for (type in TYPES[,1]) {
  base <- data.frame(MOVES_DICT[['Hidden Power']])
  base$type <- type
  MOVES_DICT[[paste('Hidden Power', type)]] <- base
}
```


```{r Extract most common moves, message=FALSE, warning=FALSE, eval=FALSE, include=FALSE}
GEN_COMMON_MOVES_DICT <- hash()
GEN_COUNTS_DICT <- hash()
for (format in c('ubers', 'ou', 'uu', 'ru', 'nu', 'pu', 'zu', 'lc')) {
  filename <- paste('gen7', format, '-0.txt', sep='')
  path <- paste('https://www.smogon.com/stats/2019-01/moveset/', filename, sep='')
  response <- GET(url=path)
  data <- content(response)
  
  # Extract sections
  names <- str_extract_all(data, '\\+ \n \\| [^\n\\|]+ \\| \n \\+.*\\+ \n \\|')[[1]]
  moves <- str_extract_all(data, '\\| Moves [^\\+]*')[[1]]
  counts <- str_extract_all(data, 'Raw count: [0-9]+')[[1]]
    
  # Clean sections
  names <- lapply(names, function(x) trimws(str_split(x, '\\|')[[1]][2]))
  moves <- lapply(moves, function(x) {
    clean <- str_remove_all(x, '[0-9]*\\.[0-9]*%|\n|  \\| ')
    result <- sapply(str_split(clean, '\\|'), function (x) {
      x <- ifelse(grepl('\\+', x), substring(x, 1, length(x) - 1), x)
      return(trimws(x))
    })
    result <- subset(result, !(result %in% c("Other", "Nothing", "", "Moves")))
    return(result)
  })
  counts <- lapply(counts, function(x) as.numeric(str_split(x, ' ')[[1]][3]))
  
  format <- toupper(format)
  for (i in 1:length(names)) {
    common_moves <- do.call(rbind, lapply(moves[[i]], function(x) MOVES_DICT[[x]]))
    name <- names[[i]]
    
    # Manual error correction
    if (name == 'Necrozma-Dusk-Mane')
      name <- 'Necrozma-Dusk Mane'
    else if (name == 'Necrozma-Dawn-Wings')
      name <- 'Necrozma-Dawn Wings'
    else if (name == 'Meowstic')
      name <- 'Meowstic-M'
    else if (name == 'NidoranM')
      name <- 'Nidoran-M'
    else if (name == 'NidoranF')
      name <- 'Nidoran-F'
  
    if (!has.key(name, GEN_COMMON_MOVES_DICT)) {
      GEN_COMMON_MOVES_DICT[[name]] <- hash()
      GEN_COUNTS_DICT[[name]] <- hash()
    }
    GEN_COMMON_MOVES_DICT[[name]][[format]] <- common_moves
    GEN_COUNTS_DICT[[name]][[format]] <- counts[[i]]
  }
}

```

```{r Synthesize multi-tier information to a single tier, eval=FALSE, include=FALSE}
UNOBSERVED = NULL
COMMON_MOVES_DICT = hash()
COUNTS_DICT = hash()
for (name in POKEDEX[,1]) {
  if (has.key(name, GEN_COMMON_MOVES_DICT)) {
    common_moves <- GEN_COMMON_MOVES_DICT[[name]]
    counts <- GEN_COUNTS_DICT[[name]]
    gen <- keys(counts)[which.max(values(counts))]
    
    COMMON_MOVES_DICT[[name]] <- common_moves[[gen]]
    COUNTS_DICT[[name]] <- sum(values(counts))
  } else {
    UNOBSERVED <- rbind(UNOBSERVED, name)
  }
}
```

```{r Extract move features and create dataset, eval=FALSE, include=FALSE}
extract_move_features <- function(pokemon) {
  common_moves <- head(COMMON_MOVES_DICT[[pokemon]], 5)
  if (is.null(common_moves))
    stop(pokemon)
  features <- common_moves |>
    summarize(prop_physical = mean(category == 'Physical'),
              prop_special = mean(category == 'Special'),
              prop_nondamaging = mean(category == 'Non-Damaging'),
              max_power = max(power),
              num_inaccurate = sum(accuracy != 100),  # TODO fix
              priority = any(priority > 0),
              stat_change = any(stat_change),
              multisetup = any(multisetup),
              heal = any(heal),
              burn = any(burn),
              poison = any(burn),
              paralyze = any(paralyze),
              sleep = any(sleep),
              confuse = any(confuse),
              status = any(status),
              hazards = any(hazards),
              switch = any(switch),
              recoil = any(recoil),
              ohko = any(ohko),
              flinch = any(flinch),
              selfweaken = any(selfweaken),
              multihit = any(multihit),
              critical = any(critical),
              protect = any(protect),
              multiturn = any(multiturn))
  
  coverage <- common_moves |>
    filter(category != 'Non-Damaging') |>
    select(type) |>
    unique()
  coverage <- merge(x=TYPES, y=coverage, by.x='name', by.y='type')
  
  effective <- lapply(coverage$atk_effectives, function(x) as.numeric(x[,2]) >= 1)
  effective <- Reduce("|", effective)
  num_effective <- sum(effective)
  
  super_effective <- lapply(coverage$atk_effectives, function(x) as.numeric(x[,2]) > 1)
  super_effective <- Reduce("|", super_effective)
  num_super_effective <- sum(super_effective)
  if (is.null(super_effective)) {
    super_effective <- data.frame(matrix(numeric(length(TYPES[,1])), nrow=1))
  } else {
    super_effective <- data.frame(matrix(super_effective, nrow=1))
  }
  colnames(super_effective) <- paste('atk_', tolower(TYPES[,1]), sep='')
  
  features <- cbind(pokemon, features, super_effective, num_super_effective, num_effective)
  return(features)
}

# Create dataset
move_features <- do.call(rbind, lapply(keys(COUNTS_DICT), extract_move_features))
dataset <- POKEDEX |>
  filter(name %in% keys(COUNTS_DICT)) |>
  mutate(usage = as.numeric(lapply(name, function(x) COUNTS_DICT[[x]]))) |>
  merge(y=move_features, by.x='name', by.y='pokemon')
save(dataset, file='dataset.Rda')
```

```{r include=FALSE}
load('dataset.Rda')
```

# Introduction

Pokémon (or Pokemon) is a role-playing video game series wherein player characters travel across a fictional region, capturing and training teams of creatures called Pokemon to use in battles against other Pokémon and Pokémon trainers to accomplish various objectives. Central to its gameplay is the turn-based battle system which has fostered a wide-reaching competitive scene, with tournaments like the Pokemon World Championships boasting prize pools of over $2,000,000 USD (The Pokémon Company, 2025).

There are many competitive formats to a Pokemon battle with various rules and clauses. In the commmon singles format, two opposing trainers field at most six Pokemon, which possess an ability, a level (which is usually set to the same for all players), an optional held item, 1-4 unique moves, 1-2 unique types (there are 18 total types, see Figure 1), and base statistics for hit points (HP), attack, special attack, defence, special defence, and speed. As a battle begins, trainers send out a single Pokemon. Each turn, players can use one of their current Pokemon's moves or switch to a different Pokemon; they are unaware of their opponent's choice during this time. Once both sides have decided to act, events play out as such: switching occurs first, followed by moves with higher priority levels, then finally the Pokemon with higher speed acts first. If a Pokemon loses all of its HP, or "faints", its trainer sends out another Pokemon until no more can stand, in which case the trainer loses the battle.

Nuances in the battle system add significant complexity to the choice of Pokemon to use on a team. For instance, moves are labelled by types and may deal extra ("super effective") or reduced damage based on the defending Pokemon's type(s) (see Figure 1 below). Moves are further classified as "physical" or "special"; physical moves use the attacking Pokemon's attack against the defender's HP and defence to calculate damage, while special moves use special attack against HP and special defence. Finally, non-damaging moves have a variety of effects like temporarily changing a Pokemon's stats, healing, causing weather or status conditions (e.g. hail, rain, poison, burn) which damage or weaken/strengthen Pokemon, and creating hazards that damage Pokemon upon switching in. It is thus important for competitive players to build teams with a wide range of types and moves rather than simply those with the highest base statistics.

<div style="text-align: center">
![**Figure 1.** Pokemon type chart. Cell numbers (blank = 1) are damage multipliers for one type against another (e.g. the cell with row Fire and column Grass is 2, so Fire does x2 damage on Grass types). If a Pokemon has two types, the multipliers for both types are used (e.g. Fire does x2 damage on Grass types and Steel types, so it does x4 damage on Steel/Grass types). Source: [Wikipedia](https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/Pokemon_Type_Chart.svg/2048px-Pokemon_Type_Chart.svg.png) ](https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/Pokemon_Type_Chart.svg/2048px-Pokemon_Type_Chart.svg.png){width=50%}
</div>

<br>

With this in mind, this project aims to uncover insights regarding Pokemon team building by answering the research question, **"What properties in a Pokemon most significantly influence its usage rate in competitive singles battles?"** The analysis will focus on Pokemon generation 7 (i.e. the Alola region introduced by Pokemon Sun/Moon) because it has the largest pool of playable pokemon; this generation is the last generation where the pool of available Pokemon includes all Pokemon from the previous generation. Furthermore, this study only considers Pokemon base statistics, types, and moves, ignoring items and abilities. This is because it was later found that items and abilities had wildly-differing effects, making it difficult to collapse into simpler categories. Furthermore, items are not unique to a Pokemon, while many abilities can uniquely identify individual Pokemon, which can result in overfitting.

Data in this study were collected from [Smogon University](https://www.smogon.com/) (or Smogon), a website specializing in competitive Pokemon resources. Smogon has forums, damage calculators, as well as a [pokedex](https://www.smogon.com/dex/sm/pokemon/), a table of all Pokemon with base statistics, abilities, movesets, and community team-building strategies for each generation. Smogon also compiles [monthly statistical analyses](https://www.smogon.com/stats/) of Pokemon battles in the form of TXT files, which include raw counts of Pokemon usages as well as common abilities, items, and moves. These battle statistics are sourced from [Pokémon Showdown!](https://pokemonshowdown.com/), a free Pokemon battle simulator that allows for building Pokemon teams, playing against random opponents online, and competing with a ranked Elo system.

# Methods

## Data Retrieval and Cleaning

### Pokemon and Moves Data

To obtain generic Pokemon data including base statistics, move details, and type effectiveness, the Smogon generation 7 pokedex was scraped. This site was selected because its user interface was simplistic, its move descriptions were written to be more standardized and technical compared to official in-game descriptions, and its Pokemon naming conventions would hopefully match the monthly battle statistics (since Smogon created both resources).

Upon retrieving the website, it became clear that the tabular data did not show in the HTML because it was dynamically injected from a Javascript object in a &lt;script&gt; tag. Thus, the Javascript code was extracted to retrieve and parse the object as a JSON. This object contained dataframes for Pokemon types and statistics, offensive type matchups, moves, items, and abilities. Nonstandard Pokemon (i.e. fanmade Pokemon from Smogon's Create-A-Pokemon project) were filtered out, the pokemon's type was converted from a variable-length array to a string, then the type effectiveness dataframe was refitted into a matrix so both offensive and defensive matchups could be more easily indexed. Features were then extracted from the moves and Pokemon dataframes (see next section)

It should be noted that some Pokemon abilities (e.g. [Levitate](https://www.smogon.com/dex/sm/abilities/levitate/), [Thick Fat](https://www.smogon.com/dex/sm/abilities/thick-fat/)) change the defensive type matchings, but these are not covered by this analysis because there also exists abilities which can nullify these effects (e.g. [Mold Breaker](https://www.smogon.com/dex/sm/abilities/mold-breaker/)). The uncertainty around these defensive changes made it difficult to incorporate into analysis, so it was ignored.

### Usage and Common Moves Data

To acquire the response variable - usage numbers - the TXT files from Smogon's monthly battle statistics were scraped. Files had been compiled per generation, tier, and format, though not all combinations had data available each month. [Data from January 2019](https://www.smogon.com/stats/2019-01/moveset/) were selected because it was one of the last months before generation 8, so the usage rates would hopefully be relatively consistent over time. The tiers used were Ubers, OU (overused), UU (underused), RU (rarely-used), NU (never-used), PU, ZU (zero-used), and LC (little cup). These tiers are defined in top-to-bottom order by Smogon (n.d.) based on usage rates and community adjudication; Pokemon from lower tiers may be used in higher tiers, but not vice versa. These tiers were included in this project to create a richer analysis, since without them the vast majority of Pokemon have no utility and thus would never be used at all.

After web scraping the TXT file, regex was used to extract the rows corresponding to names, raw counts, and most common moves (which was variable-sized). Moves representing "Nothing" (if $<4$ moves were chosen) and "Other" were removed. For each Pokemon, the raw counts were summed across tiers, while the most common moves from the most-played tier were extracted. It was initially attempted to use the most common moves from the Pokemon's intended tier (specified by the Pokemon dataframe in Table 1), but some Pokemon had no usage for their specified tier, suggesting that the tier list changed since January 2019. This analysis focused on commonly-used moves instead of entire move pools because the former is much more informative of a Pokemon's competitive strategy.

### Data Wrangling

The top 5 most common moves were taken and merged with the moves dataframe. This analysis used the 5 top moves instead of top 4 in order to account for small potential variations in play-style. Once feature engineering was performed (see next section), the move features were merged with the Pokemon dataframe. Inconsistent naming conventions were identified in the process and manually corrected:

- [Hidden Power](https://bulbapedia.bulbagarden.net/wiki/Hidden_Power_(move)) is a unique move whose type can vary across even the same Pokemon. It was notated in the TXT file by its actual type (e.g. 'Hidden Power Ice') but only as 'Hidden Power' in the moves dataframe, where new rows for each type had to be manually added.

- Differences in writing conventions existed between dataframe and TXT files for some multi-form Pokemon like 'NidoranM' and 'NidoranF' (corrected to 'Nidoran-M' and 'Nidoran-F'), as well as 'Necrozma-Dusk-Mane' and 'Necrozma-Dawn-Wings' (corrected to 'Necrozma-Dusk Mane' and 'Necrozma-Dawn Wings')

The Pokemon dataframe had 988 observations, which became 952 after merging. Three pokemon genuinely saw zero usage - Tranquill, Gothita, and Scatterbug - while others were either not introduced in the mainline Pokemon game (e.g. Melmetal, Eevee-Starter, Pikachu-Starter) or were a specific Pokemon form. Indeed, some Pokemon have abilities that change their form in the middle of a game (e.g. [Aegislash](https://www.smogon.com/dex/sm/pokemon/aegislash/)), which may affect some base statistics, resulting in extra rows created for this Pokemon's forms, which this analysis did not consider for the sake of simplicity.

No outliers and implausible values were detected in this final dataset.


## Feature Engineering

Relevant initial features in all the scraped dataframes are shown in Table 1 below:

<div style="text-align: center">
**Table 1**. Relevant initial features in the Pokemon (left) and moves (right) dataframe
</div>

```{r Initial dataframes, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| Feature (Pokemon) | Type | Description | Feature (Move) | Type | Description  |
|:--------|:---|:---------------|:-------|:---|:-------------------|
| name | chr | Pokemon's name | name | chr | Move's name |
| hp | int | Hit points | category | chr | Either 'Physical', 'Special', or 'Non-Damaging' |
| atk | int | Attack | power | int | Move's damage, if it is damaging (0 otherwise) |
| def | int | Defence | accuracy | int | Probability of a move successfully executing |
| spa | int | Special Attack | priority | int | Move's priority level (7 to -7) |
| spd | int | Special Defence | description | chr | Move's effects |
| spe | int | Speed | type | chr | Move's type | | | |
| types | chr | Pokemon's types, comma-separated | | | |
| formats | chr | Pokemon's Smogon tier | | | |
"
cat(tabl)
```

Table 2 lists the features that were manually engineered from the Pokemon dataframe's features.

<div style="text-align: center">
**Table 2**. Engineered features from the Pokemon dataframe
</div>

```{r Pokemon dataframe engineered, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| Feature | Type | Description |
|:-------|:---|:------------------------------|
| total | int | Sum of all base statistics |
| bulk | num | (hp + def) / 2, a more well-rounded measure of defence |
| spbulk | num | (hp + spd) / 2, a more well-rounded measure of special defence |
| typecount | factor | Number of unique types, either 1 or 2 |
| best_stat | chr | Estimation of the Pokemon's primary strength. Can be 'atk', 'phatk', 'spatk', 'bulk', 'phbulk', 'spbulk', 'spe' |
| weaknesses | num | Number of defensive weaknesses (where x2, x4) |
| resistances | num | Number of defensive resistances (where x0.5, x0.25, x0) |
| is_{type} | logi | Whether the pokemon is {type} (for all 18 types) |
| def_{type} | factor | The pokemon's defensive multiplier against {type} (for all 18 types). Can be 0, 0.25, 0.5, 1, 2, 4 |
"
cat(tabl)
```

The `best_stat` feature is calculated based on the best statistic out of `atk`, `spa`, `bulk`, `spbulk`, and `spe`:

- 'spe' if it is `spe`
- 'atk' if it is `atk` or `spa`, where `atk` and `spa` differ by at most 10
- 'phatk' if it is `atk` and `atk > spa + 10`
- 'spatk' if it is `spa` and `spa > atk + 10`
- 'bulk' if it is `bulk` or `spbulk`, where `bulk` and `spbulk` differ by at most 10
- 'phbulk' if it is `bulk` and `bulk > spbulk + 10`
- 'spbulk' if it is `spbulk` and `spbulk > bulk + 10`

Table 3 lists the features engineered from the moves dataframe's features. Apart from `priority` and `atk_{type}`, the logical-based features all used string matching from the move description to determine if a move has a described effect.

<div style="text-align: center">
**Table 3**. Engineered features from the moves dataframe. These features apply to the top 5 most common moves of a Pokemon. 
</div>

```{r Moves dataframe engineered, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| Feature | Type | Description |
|:-------|:---|:----------------------------------|
| prop_physical | num | Proportion of moves that are physical |
| prop_special | num | Proportion of moves that are special |
| prop_nondamaging | num | Proportion of moves that are non-damaging |
| num_inaccurate | int | Number of moves with accuracy < 100% |
| priority | logi | If there is a move with priority > 0 |
| stat_change | logi | If there is a non-damaging move that raises/lowers stats |
| multisetup | logi | If there is a non-damaging move that does something for multiple turns |
| heal | logi | If there is a move that heals |
| status | logi | If there is a non-damaging move that inflicts a status effect (i.e. burn, poison, paralysis, sleep, confusion) |
| hazards | logi | If there is a move that creates hazards (which damage opponents on switch-in) |
| switch | logi | If there is a move that forces/prevents a switch either for the player or the opponent |
| recoil | logi | If there is a move, typically a very powerful move, that also hurts the player |
| ohko | logi | If there is a move that may involve instantly fainting the opponent or player |
| flinch | logi | If there is a move that can flinch the opponent, causing them to skip their move |
| selfweaken | logi | If there is a move, typically a very powerful move, that lowers the player's stats after usage |
| multihit | logi | If there is a move that hits multiple times |
| protect | logi | If there is a move that protects the player from something for one turn |
| atk_{type} | logi | If there is a damaging move that is super-effective against {type} (for all 18 types) |
| num_super_effective | int | Number of unique types that can be hit super-effectively from the moveset; a Pokemon's offensive coverage |
"
cat(tabl)
```


## Data Exploration

The following tools were utilized for data exploration:

- `dplyr` to calculate means and proportions of variable values.

- `ggplot2` to create histograms of Pokemon usages, box plots of usage against multiclass categorical variables (e.g. tier, best stat, number of types), scatter plots of usage against continuous variables (e.g. base statistics), 2D heatmaps/histograms of usage against small count variables (which would otherwise clump together in a regular plot, e.g. number of weaknesses/resistances), and a correlation matrix of base statistics to each other.

- `patchwork` to combine topically-related `ggplot` diagrams into a single figure.

- `kable` to display the dataset and results of ANOVA tests conducted with `anova`.

- `lm` to fit simple linear regression models of base statistics to usage.


# Preliminary Results

## Usage

```{r eval=FALSE, include=FALSE}
dataset |>
  summarize(mean = mean(usage),
            median = median(usage),
            var = var(usage),
            std = var ** 0.5)
```

The distribution of usages is extremely right-skewed, with a mean of 37,309 far exceeding the median of 7,981, and a logarithmic-scale histogram of usages appearing vaguely  symmetrical (Figure 1). Being an example of count data, it seems appropriate to model the counts as a Poisson distribution (where $\text{E}[X] = \text{Var}[X]$), however the usage's variance of 7,486,205,609 suggests there is far more variance than expected, so an overdispersed model like the Negative Binomial may be worth considering. Figure 1's appearance is also roughly normal, meaning a linear model fitted to `log(usage)` could suffice.


```{r fig.pos='H', fig.height=4, fig.align='center', echo=FALSE, message=FALSE, warning=FALSE, fig.width=8}
p1 <- dataset |>
  ggplot(aes(x=usage)) +
    geom_histogram(bins=40) +
    scale_x_log10() +
    theme_light() +
    labs(title='Histogram of Pokemon Usage',
         x='Usage (logarithmic scale)', y='Count')

p2 <- dataset |>
  mutate(formats = factor(formats, levels=c('LC', 'ZU', 'PU', 'NU', 'RU', 'UU', 'OU', 'Ubers'))) |>
  ggplot(aes(x=usage, y=formats)) +
    geom_boxplot() +
    scale_x_log10() +
    theme_light() +
    labs(title='Pokemon Usage by Tier', x='Usage (logarithmic scale)', y='Tier')

(p1 | p2) + plot_layout(widths=c(2, 1))
```

<div style="text-align: center">
**Figure 2**. Histogram of Pokemon usage in the dataset independently and by tier. The distribution of Pokemon is extremely right-skewed, with Pokemon in higher tiers being more commonly used.
</div>


Pokemon usage is also heavily dependent on tier, with mid-to-high-level tiers like OU, UU, and RU being the most common tier by far and low-level tiers like LC and ZU being the least common. Though the tier does not affect a Pokemon's performance in battle, the model may need to adjust for it. The tier-usage trend also manifests in Table 4, which previews the extremes of the dataset by usage. The top 5 most common Pokemon are all dual-types in OU with high total base stats, while the top 5 least common Pokemon have low stats, are monotype, and are mostly in LC, which suggests all these factors heavily determine usage.

<div style="text-align: center">
**Table 4**. Most and least commonly-used Pokemon in the dataset.
</div>

```{r echo=FALSE}
p1 <- dataset |>
  arrange(desc(usage)) |>
  select(name, types, total, formats, usage) |>
  head(5)

p2 <- dataset |>
  arrange(desc(usage)) |>
  select(name, types, total, formats, usage) |>
  tail(5)

knitr::kable(x=rbind(p1, c('...', '...', '...', '...', '...'), p2),
             row.names=FALSE,
             col.names=c('Name', 'Types', 'Total', 'Tier', 'Usage'))
```

## Base Statistics

Analyzing Pokemon usage by base statistics, every value appears to follow the same trend (Figure 3), being mostly distributed between 40 and 120 with more large outliers than small outliers. Plotted against usage, there is a noisy but clearly nonlinear positive correlation that is roughly linear when the statistic is $<100$, but diminishes in slope as the statistic increases; once the statistic is $>100$, further improvements do not improve usage but reduces the variance in usage. This suggests these variables could be best modeled with a GAM.

```{r eval=FALSE, include=FALSE}
summary(lm(log(usage) ~ hp, data=dataset))
summary(lm(log(usage) ~ atk, data=dataset))
summary(lm(log(usage) ~ spa, data=dataset))
summary(lm(log(usage) ~ def, data=dataset))
summary(lm(log(usage) ~ spd, data=dataset))
summary(lm(log(usage) ~ spe, data=dataset))
```

Furthermore, when a linear model is between logged usage and each base statistic, all slope parameters are significant ($p <2 \cdot 10^{-16}$), with $R^2$ varying from 0.16 to 0.27, further confirming the observed positive correlation.

```{r echo=FALSE, fig.align='center'}
dataset |>
  tidyr::pivot_longer(cols=c(hp, atk, spa, def, spd, spe),
               names_to='stat',
               values_to='value') |>
  mutate(stat = case_when(stat == 'atk' ~ 'Attack',
                          stat == 'spa' ~ 'Special Attack',
                          stat == 'hp' ~ 'HP',
                          stat == 'def' ~ 'Defence',
                          stat == 'spd' ~ 'Special Defence',
                          stat == 'spe' ~ 'Speed'),
         stat = factor(stat, levels=c('HP', 'Attack', 'Special Attack', 'Defence', 'Special Defence', 'Speed'))) |>
  ggplot(aes(x=value, y=usage)) +
    geom_point(size=1, alpha=0.3) +
    scale_y_log10() +
    theme_light() +
    facet_wrap(~stat, scales='free_x') +
    labs(title='Pokemon Usage by Base Statistics', x='Base Statistic Value', y='Usage (logarithmic scale)')
```

<div style="text-align: center">
**Figure 3**. Scatter plots of a Pokemon's base statistics against usage. All follow a similar noisy but positive correlation.
</div>


A possible reason for the identical trends across base statistics could be that they are highly-correlated. Plotting a correlation matrix in Figure 4 confirms this hypothesis, which shows positive correlations between every value with each other (with the exception of speed to defence, with no relationship). This correlation is likely explained by the game's evolution mechanic: Pokemon that reach a certain level can evolve into a stronger Pokemon where all stats are typically improved, resulting in a distribution of Pokemon with positively-correlated base statistics. To reduce complexity and multicollinearity, it may suffice to use the total instead of individual stats in the final model. 


```{r fig.align='center', echo=FALSE}
library(ggcorrplot)

dataset |>
  select(hp, atk, spa, def, spd, spe) |>
  rename(HP=hp, Attack=atk, 'Special Attack'=spa, Defence=def,
         'Special Defence'=spd, Speed=spe) |>
  cor() |>
  ggcorrplot() +
  labs(title='Correlation Matrix, Pokemon Base Statistics')
```

<div style="text-align: center">
**Figure 4**. Correlation matrix of all Pokemon base statistics. All variables are correlated positively with each other, except for speed and defence which have no correlation.
</div>

```{r eval=FALSE, include=FALSE}
dataset |>
  group_by(best_stat) |>
  summarize(count = n())
```

Out of the 952 Pokemon in the dataset, 503 (52.8%) can be said to be attack-based (with 255 physical attackers, 169 special attackers, and 79 general attackers), 271 (28.5%) are defence-based (with 58 physical defenders, 42 special defenders, and 171 general defenders), and 178 are speed-based (18.7%). Analyzed against usage (Figure 5), primarily fast-moving Pokemon are the least likely to be used. Special-based Pokemon are more likely to be used than physical-based Pokemon, and physical/special defenders/attackers are more likely to be used than general defenders/attackers. This may be explained by there simply being more physical-based Pokemon to choose from. 

Although an ANOVA fit between logged usage and `best_stat`, reveals a p-value of $1.813 \times 10^{-5}$, confirming there is some predictive power for a Pokemon's best statistic, it should be noted that the method to measure the value itself fails for Pokemon with very well-rounded stats (e.g. [Arceus](https://www.smogon.com/dex/sm/pokemon/arceus/), [Sunkern](https://www.smogon.com/dex/sm/pokemon/sunkern/)) and needs additional engineering.

```{r eval=FALSE, include=FALSE}
anova(lm(log(usage) ~ best_stat, data=dataset))
```


```{r fig.align='center', echo=FALSE}
dataset |>
  mutate(best_stat = case_when(best_stat == 'atk' ~ 'Attack',
                               best_stat == 'phatk' ~ 'Physical Attack',
                               best_stat == 'spatk' ~ 'Special Attack',
                               best_stat == 'bulk' ~ 'Bulk',
                               best_stat == 'phbulk' ~ 'Physical Bulk',
                               best_stat == 'spbulk' ~ 'Special Bulk',
                               best_stat == 'spe' ~ 'Speed'),
         best_stat = factor(best_stat, levels=c('Attack', 'Physical Attack', 'Special Attack', 'Bulk', 'Physical Bulk', 'Special Bulk', 'Speed'))) |>
  ggplot(aes(x=usage, y=best_stat)) +
    geom_boxplot() +
    scale_x_log10() +
    theme_light() +
    labs(title='Pokemon Usage by Best Stat', x='Usage (logarithmic scale)', y='')
```

<div style="text-align: center">
**Figure 5**. Box and whisker plots of a Pokemon's best stat type against usage. Special-based Pokemon are used most, followed by physical-based Pokemon, followed by general attackers/defenders, followed by speed-based Pokemon. 
</div>


## Typing

Figure 6 shows various 2D histograms and a box-whisker plot to assess the predictive power of a type-related features. It was hypothesized that Pokemon with less weaknesses, more resistances, and more super-effective coverage would be more useful competitively and thus used more often. However, apart from the number of resistances, there does not appear to be a strong correlation, if there exists one at all, between usage and coverage or between usage and number of weaknesses. Perhaps having many weaknesses and poor coverage is not problematic if a Pokemon is not primarily defensive in nature, while having many resistances is good regardless of the Pokemon's primary use cases. It may be necessary to combine `best_stat` with model weaknesses and coverage to properly model the hypothesized effect.

```{r fig.align='center', echo=FALSE, message=TRUE, warning=FALSE}
p1 <- dataset |>
  ggplot(aes(x=(num_super_effective + 0.5), y=usage)) +
    stat_bin_2d(binwidth=1) +
    scale_fill_gradient(low='#E4EFF9', high='#2171B5') +
    scale_y_log10() +
    theme_light() +
    labs(x='Number of Types Hit Super-Effectively', y='Usage (logarithmic scale)', fill='Count')

p2 <- dataset |>
  ggplot(aes(x=(weaknesses + 0.5), y=usage)) +
    stat_bin_2d(binwidth=1) +
    scale_fill_gradient(low='#E4EFF9', high='#2171B5') +
    scale_y_log10() +
    theme_light() +
    labs(x='Number of Weaknesses', y='', fill='Count')

p3 <- dataset |>
  ggplot(aes(x=resistances, y=usage)) +
    stat_bin_2d(binwidth=1) +
    scale_fill_gradient(low='#E4EFF9', high='#2171B5') +
    scale_y_log10() +
    theme_light() +
    labs(x='Number of Resistances', y='Usage (logarithmic scale)', fill='Count')

p4 <- dataset |>
  ggplot(aes(x=typecount, y=usage)) +
    geom_boxplot() +
    scale_y_log10() +
    theme_light() +
    labs(x='Number of Types', y='')

(p1 | p2) / (p3 | p4)
```

<div style="text-align: center">
**Figure 6**. 2D histogram plots and box-plot of usage against type-related features, including the number of types a Pokemon's top 5 most common moves could hit super-effectively, plus a Pokemon's number of types, weaknesses, and resistances. Only the number of types and resistances shows a positive correlation with usage.
</div>

Another noticed trend is that having more types leads to increased usage. This is difficult to understand, but could be another byproduct of evolutionary mechanics, a confounder variable. Pokemon commonly gain an additional type as they evolve into stronger (and thus more-used) Pokemon.

An alternative and more in-depth method to analyzing the effect of Pokemon typing on usage is to analyze the effect for each type separately. Table 5's three ANOVA tests indicate that, to a 0.05 level,

- There are 10 types whose presence or absence significantly determine usage: normal, grass, fighting, flying psychic, bug, dragon, dark, steel, and fairy.

- Defensive matchups against 7 types significantly determine usage: normal, grass, electric, poison, ground, flying, psychic

- Offensive matchups against 11 types significantly determine usage, including all types except grass, fighting, poison, bug, rock, steel, and fairy.

Since many of the variables are not significant, it is probably better to use at most one of the three sets of variables in the final model to prevent overfitting. Furthermore, at this level of granular detail, it may also be difficult to explain why specific types are more important than others for determining usage.

<div style="text-align: center">
**Table 5**. Significance tables for three separate ANOVA tests for logged usage against the presence of a type in a Pokemon (left), the defensive type multiplier against an attacking type (middle), and the offensive type multiplier against a defending type (right). 
</div>

```{r echo=FALSE}
a1 <- lm(log(usage) ~ is_normal + is_fire + is_water + is_grass + is_electric + is_ice + is_fighting + is_poison + is_ground + is_flying + is_psychic + is_bug + is_rock + is_ghost + is_dragon + is_dark + is_steel + is_fairy, data=dataset) |>
  anova() |>
  as.data.frame()
a1 <- a1 |>
  mutate(Feature = rownames(a1)) |>
  select(Feature, 'F value', 'Pr(>F)')

a2 <- lm(log(usage) ~ def_normal + def_fire + def_water + def_grass + def_electric + def_ice + def_fighting + def_poison + def_ground + def_flying + def_psychic + def_bug + def_rock + def_ghost + def_dragon + def_dark + def_steel + def_fairy, data=dataset) |>
  anova() |>
  as.data.frame()
a2 <- a2 |>
  mutate(Feature = rownames(a2)) |>
  select(Feature, 'F value', 'Pr(>F)')


a3 <- lm(log(usage) ~ atk_normal + atk_fire + atk_water + atk_grass + atk_electric + atk_ice + atk_fighting + atk_poison + atk_ground + atk_flying + atk_psychic + atk_bug + atk_rock + atk_ghost + atk_dragon + atk_dark + atk_steel + atk_fairy, data=dataset) |>
  anova() |>
  as.data.frame()
a3 <- a3 |>
  mutate(Feature = rownames(a3)) |>
  select(Feature, 'F value', 'Pr(>F)')

cbind(a1, a2, a3)[1:(nrow(a1)-1),] |>
  knitr::kable(digits=4, row.names=FALSE)
```

## Move Details

Finally, the specific mechanisms of moves in a Pokemon's common movepool are analyzed against usage using ANOVA. From Table 6, it appears that the presence of special moves, multi-turn setup moves, status-inflicting moves, hazard-related moves, switching-related moves, self-weakening moves, and multi-hitting moves significantly impacts usage. The signifance of having special moves appears to align with the previous observation of special-based Pokemon being more widely-used. These results suggest that a subset of these predictors can be used in the final model.

<div style="text-align: center">
**Table 6**. ANOVA test for a Pokemon's usage against whether their common movepool contains moves with specific properties.
</div>

```{r echo=FALSE}
a <- lm(log(usage) ~ (prop_physical > 0) + (prop_special > 0) + (prop_nondamaging > 0) + (num_inaccurate > 0) + priority + stat_change + multisetup + heal + status + hazards + switch + recoil + ohko + flinch + selfweaken + multihit + protect, data=dataset) |>
  anova() |>
  as.data.frame()
a |>
  mutate(Feature = rownames(a)) |>
  select(Feature, Df, 'Sum Sq', 'Mean Sq', 'F value', 'Pr(>F)') |>
  knitr::kable(digits=4, row.names=FALSE)
```

# Summary

This analysis has hitherto demonstrated that a Pokemon's competitive usage is significantly affected by its base statistics, typing, and top 5 most common moves. Specifically, larger base statistics, dual-types, special-attacking Pokemon, and better defensive typings appear to correlate with increased competitive usage. This work suggests that tiers and Pokemon evolution are confounding variables, and that analysis by individual base stat does not lead to very clear and insightful conclusions. The relationship of typing and moveset to usage was found to be less straightforward compared to base statistics and may require further exploration with predictor interactions.

The scope of this work has included exploring the widest possible variety of variables and conducting tests of group of similar variables together. Future work will require simplifying the set of predictors to an efficient subset, testing for variable interactions, and finding the best way to present a feature (e.g. performing a shallower type analysis by aggregating counts of weaknesses/resistances or including a predictor per type). Furthermore, this work only conducted preliminary ANOVA tests and linear regressions using small subset of variables at a time. The final project will include a full linear regression model, as well as more complex models like GLMs, GAMs, and decision tree models.

# Bibliography

The Pokémon Company. (2025). *2025 Pokémon World Championships*. Pokémon. Retrieved 16 March, 2025, from https://www.pokemon.com/us/play-pokemon/pokemon-events/championship-series/2025/world-championships

Smogon University. (n.d.) *An Introduction to Smogon's Tier System*. Retrieved 16 March, 2025, from https://www.smogon.com/bw/articles/bw_tiers

 